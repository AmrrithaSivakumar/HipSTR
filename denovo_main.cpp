#include <getopt.h>
#include <stdlib.h>
#include <time.h>

#include <iostream>
#include <set>
#include <string>
#include <sstream>
#include <vector>

#include "error.h"
#include "stringops.h"
#include "version.h"

#include "pedigree.h"
#include "haplotype_tracker.h"
#include "vcf_input.h"
#include "vcflib/src/Variant.h"

bool file_exists(std::string path){
  return (access(path.c_str(), F_OK) != -1);
}

void print_usage(){
  std::cerr << "Usage: DenovoFinder --fam <fam_file> --snp-vcf <phased_snps.vcf.gz> --str-vcf <str_gts.vcf.gz> [OPTIONS]" << "\n" << "\n"
    
	    << "Required parameters:" << "\n"
	    << "\t" << "--fam      <fam_file>            "  << "\t" << "FAM file containing pedigree information for samples of interest"                     << "\n" 
	    << "\t" << "--snp-vcf  <phased_snps.vcf.gz>  "  << "\t" << "Bgzipped input VCF file containing phased SNP genotypes for the samples."             << "\n" 
	    << "\t" << "                                 "  << "\t" << " File should be identical to --snp-vcf argument provided to HipSTR during genotyping" << "\n"
	    << "\t" << "--str-vcf  <str_gts.vcf.gz>      "  << "\t" << "Bgzipped input VCF file containing STR genotypes previously generated by HipSTR"      << "\n" << "\n"
    
	    << "Optional output parameters:" << "\n"
	    << "\t" << "--log <log.txt>                  "  << "\t" << "Output the log information to the provided file. By default, the log will be "        << "\n"
	    << "\t" << "                                 "  << "\t" << " written to standard err"                                                             << "\n" 

	    << "Other optional parameters:" << "\n"
	    << "\t" << "--help                           "  << "\t" << "Print this help message and exit"                                                     << "\n"
	    << "\t" << "--chrom         <chrom>          "  << "\t" << "Only consider STRs on the provided chromosome"                                        << "\n"
	    << "\t" << "--haploid-chrs  <list_of_chroms> "  << "\t" << "Comma separated list of chromosomes to treat as haploid"                              << "\n"
	    << "\t" << "                                 "  << "\t" << " By default, all chromosomes are treated as diploid"                                  << "\n"
	    << "\t" << "--skip-snps     <snp_list.txt>   "  << "\t" << "File containing SNPs to omit from the analysis. Each line should contain a "          << "\n"
	    << "\t" << "                                 "  << "\t" << " position in the format CHROMOSOME:START"                                             << "\n"
	    << "\t" << "--version                        "  << "\t" << "Print DenovoFinder version and exit"                                                  << "\n"
	    << "\n";
}
  
void parse_command_line_args(int argc, char** argv, std::string& fam_file, std::string& snp_vcf_file, std::string& str_vcf_file,
			     std::string& chrom, std::string& log_file, std::string& haploid_chr_string, std::string& snp_skip_file){
  if (argc == 1 || (argc == 2 && std::string("-h").compare(std::string(argv[1])) == 0)){
    print_usage();
    exit(0);
  }

  int print_help    = 0;
  int print_version = 0;

  static struct option long_options[] = {
    {"chrom",           required_argument, 0, 'c'},
    {"fam",             required_argument, 0, 'f'},
    {"log",             required_argument, 0, 'l'},
    {"h",               no_argument, &print_help, 1},
    {"help",            no_argument, &print_help, 1},
    {"version",         no_argument, &print_version, 1},
    {"skip-snps",       required_argument, 0, 'm'},
    {"str-vcf",         required_argument, 0, 'o'},
    {"snp-vcf",         required_argument, 0, 'v'},
    {"haploid-chrs",    required_argument, 0, 't'},
    {0, 0, 0, 0}
  };

  std::string filename;
  int c;
  while (true){
    int option_index = 0;
    c = getopt_long(argc, argv, "c:f:l:m:o:t:v:", long_options, &option_index);
    if (c == -1)
      break;

    switch(c){
    case 0:
      break;
    case 'c':
      chrom = std::string(optarg);
      break;
    case 'f':
      fam_file = std::string(optarg);
      break;
    case 'l':
      log_file = std::string(optarg);
      break;
    case 'm':
      snp_skip_file = std::string(optarg);
      break;
    case 'o':
      str_vcf_file = std::string(optarg);
      break;
    case 't':
      haploid_chr_string = std::string(optarg);
      break;
    case 'v':
      snp_vcf_file = std::string(optarg);
      break;
    case '?':
      printErrorAndDie("Unrecognized command line option");
      break;
    default:
      abort();
      break;
    }
  }

  if (optind < argc) {
    std::stringstream msg;
    msg << "Did not recognize the following command line arguments:" << "\n";
    while (optind < argc)
      msg << "\t" << argv[optind++] << "\n";
    msg << "Please check your command line syntax or type ./DenovoFinder --help for additional information" << "\n";
    printErrorAndDie(msg.str());
  }

  if (print_version == 1){
    std::cerr << "DenovoFinder version " << VERSION << std::endl;
    exit(0);
  }
  if (print_help){
    print_usage();
    exit(0);
  }
}

void read_site_skip_list(std::string input_file, std::set<std::string>& sites_to_skip){
  sites_to_skip.clear();
  std::ifstream input(input_file.c_str());
  std::string line;
  while (std::getline(input, line))
    sites_to_skip.insert(line);
  input.close();
}

int main(int argc, char** argv){
  double total_time = clock();

  std::stringstream full_command_ss;
  full_command_ss << "DenovoFinder-" << VERSION;
  for (int i = 1; i < argc; i++)
    full_command_ss << " " << argv[i];
  std::string full_command = full_command_ss.str();

  std::string fam_file = "", snp_vcf_file = "", str_vcf_file = "";
  std::string chrom = "", log_file = "", haploid_chr_string  = "", snp_skip_file = "";
  parse_command_line_args(argc, argv, fam_file, snp_vcf_file, str_vcf_file, chrom, log_file, haploid_chr_string, snp_skip_file);

  if (fam_file.empty())
    printErrorAndDie("--fam option required");
  else if (snp_vcf_file.empty())
    printErrorAndDie("--snp-vcf option required");
  else if (str_vcf_file.empty())
    printErrorAndDie("--str-vcf option required");

  // Check that the FAM file exists
  if (!file_exists(fam_file))
    printErrorAndDie("FAM file " + fam_file + " does not exist. Please ensure that the path provided to --fam is valid");
  
  // Check that the SNP VCF file exists, has a tabix index and then open it
  vcflib::VariantCallFile snp_vcf;
  if (!file_exists(snp_vcf_file))
    printErrorAndDie("SNP VCF file " + snp_vcf_file + " does not exist. Please ensure that the path provided to --snp-vcf is valid");  
  if (!file_exists(snp_vcf_file + ".tbi"))
    printErrorAndDie("No .tbi index found for the SNP VCF file. Please index using tabix and rerun DenovoFinder");
  if (!snp_vcf.open(snp_vcf_file))
    printErrorAndDie("Failed to open the input SNP VCF file");

  // Check that the STR VCF file exists, has a tabix index and then open it
  vcflib::VariantCallFile str_vcf;
  if (!file_exists(str_vcf_file))
    printErrorAndDie("STR VCF file " + str_vcf_file + " does not exist. Please ensure that the path provided to --str-vcf is valid");
  if (!file_exists(str_vcf_file + ".tbi"))
    printErrorAndDie("No .tbi index found for the STR VCF file. Please index using tabix and rerun DenovoFinder");
  if (!str_vcf.open(str_vcf_file))
    printErrorAndDie("Failed to open the input STR VCF file");
  
  if (!chrom.empty()){
    // TO DO...
  }

  std::ofstream log_;
  if (!log_file.empty()){
    log_.open(log_file, std::ofstream::out);
  if (!log_.is_open())
    printErrorAndDie("Failed to open the log file: " + log_file);
  }

  if (!haploid_chr_string.empty()){
    std::vector<std::string> haploid_chroms;
    split_by_delim(haploid_chr_string, ',', haploid_chroms);
    printErrorAndDie("DenovoFinder does not currently support haploid chromosomes. We apologize for the inconvenience");
  }

  std::ostream& logger = (log_file.empty() ?  std::cerr : log_);

  // Read the original pedigree
  PedigreeGraph pedigree(fam_file);

  // Determine which samples have both SNP and STR data
  std::set<std::string> samples_with_data;
  std::set<std::string> snp_samples(snp_vcf.sampleNames.begin(), snp_vcf.sampleNames.end()), str_samples(str_vcf.sampleNames.begin(), str_vcf.sampleNames.end());
  for (auto sample_iter = snp_samples.begin(); sample_iter != snp_samples.end(); sample_iter++)
    if (str_samples.find(*sample_iter) != str_samples.end())
      samples_with_data.insert(*sample_iter);

  // Remove irrelevant samples from pedigree
  pedigree.prune(samples_with_data);

  // Identify simple nuclear families in the pedigree
  std::vector<PedigreeGraph> pedigree_components;
  pedigree.split_into_connected_components(pedigree_components);
  
  std::vector<NuclearFamily> families;
  int num_others = 0;
  for (unsigned int i = 0; i < pedigree_components.size(); i++){
    if (pedigree_components[i].is_nuclear_family())
      families.push_back(pedigree_components[i].convert_to_nuclear_family());
    else
      num_others++;
  }
  logger << "Detected " << families.size() << " nuclear families and " << num_others << " other family structures\n"
	 << "\tOnly the nuclear families will undergo de novo analysis\n\n";

  // Read a list of sites to skip
  std::set<std::string> sites_to_skip;
  if (!snp_skip_file.empty())
    read_site_skip_list(snp_skip_file, sites_to_skip);

  // TO DO: Test pedigree reading/structure manipulation...


  PhasedGL phased_gls;

  // Iterate through the SNP VCF to determine haplotype sharing at each position
  HaplotypeTracker haplotype_tracker(families);
  int32_t window_size = 1000000;
  vcflib::Variant variant(snp_vcf);
  int32_t count = 0;
  while (snp_vcf.getNextVariant(variant)){
    std::string key = variant.sequenceName + ":" + std::to_string(variant.position);
    if (sites_to_skip.find(key) != sites_to_skip.end())
      continue;

    haplotype_tracker.add_snp(variant);

    if (++count % 1000 == 0){
      std::cerr << variant.position << std::endl;
      int32_t position = variant.position;
      while (haplotype_tracker.next_snp_position() < position-window_size && haplotype_tracker.next_snp_position() != -1)
	haplotype_tracker.remove_next_snp();
      std::cerr << haplotype_tracker.num_stored_snps()  << std::endl;

      int d11, d12, d21, d22;
      for (auto family_iter = families.begin(); family_iter != families.end(); family_iter++){
	for (auto child_iter = family_iter->get_children().begin(); child_iter != family_iter->get_children().end(); child_iter++){
	  haplotype_tracker.edit_distances(*child_iter, family_iter->get_mother(), d11, d12, d21, d22);
	  std::cout << *child_iter << " " << position << " " << d11 << " " << d12 << " " << d21 << " " << d22 << "\t";

	  haplotype_tracker.edit_distances(*child_iter, family_iter->get_father(), d11, d12, d21, d22);
	  std::cout << d11 << " " << d12 << " " << d21 << " " << d22 << std::endl;
	}
      }
    }
  }
    

  total_time = (clock() - total_time)/CLOCKS_PER_SEC;
  logger << "DenovoFinder execution finished: Total runtime = " << total_time << " sec" << std::endl;

  if (!log_file.empty())
    log_.close();

  return 0;  
}
